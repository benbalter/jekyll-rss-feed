# frozen_string_literal: true

module JekyllFeed
  class Generator < Jekyll::Generator
    safe true
    priority :lowest

    # Main plugin action, called by Jekyll-core
    def generate(site)
      @site = site

      @feeds = []
      @feed_templates = {}

      # Define the main feeds
      (config["feeds"] || { nil => nil }).keys.each do |id|
        @feeds << { :id => id || "posts",
                    :collection => "posts",
                    :category => nil }
      end

      # Define the collection/category autogenerated feeds
      #
      # Remember, this outer loop includes the "posts" collection.
      collections.each do |collection, meta|
        (meta["categories"] + [nil]).each do |category|
          # This is the main feed and its covered above
          next if collection == "posts" and category.nil?

          if collection == "posts"
            id = "#{category}"
          elsif category.nil?
            id = "#{collection}"
          else
            id = "#{collection}/#{category}"
          end

          @feeds << { :id => id,
                      :collection => collection,
                      :category => category }
        end
      end

      # Now generate the feeds
      @feeds.each do |feed|
        path = feed_path(:collection => feed[:collection], :category => feed[:category], :id => feed[:id])

        Jekyll.logger.info "Jekyll Feed:", "Generating feed for #{feed[:id]} at #{path}"

        next if file_exists?(path)

        @site.pages << make_page(path,
                                 feed[:collection],
                                 :category => feed[:category],
                                 :id => feed[:id])
      end
    end

    private

    # Matches all whitespace that follows
    #   1. A '>', which closes an XML tag or
    #   2. A '}', which closes a Liquid tag
    # We will strip all of this whitespace to minify the template
    MINIFY_REGEX = %r!(?<=>|})\s+!.freeze

    # Returns the plugin's config or an empty hash if not set
    def config
      @config ||= @site.config["feed"] || {}
    end

    # Determines the destination path of a given feed
    #
    # collection - the name of a collection, e.g., "posts"
    # category - a category within that collection, e.g., "news"
    #
    # Will return "/feed.xml", or the config-specified default feed for posts
    # Will return `/feed/category.xml` for post categories
    # WIll return `/feed/collection.xml` for other collections
    # Will return `/feed/collection/category.xml` for other collection categories
    def feed_path(collection: "posts", category: nil, id: nil)
      prefix = collection == "posts" ? "/feed" : "/feed/#{collection}"
      return "#{prefix}/#{category}.xml" if category

      path = config.dig("feeds", id) ||
        collections.dig(collection, "path") ||
        "#{prefix}.xml"
    end

    # Returns a hash representing all collections to be processed and their metadata
    # in the form of { collection_name => { categories = [...], path = "..." } }
    def collections
      return @collections if defined?(@collections)

      @collections = if config["collections"].is_a?(Array)
                       config["collections"].map { |c| [c, {}] }.to_h
                     elsif config["collections"].is_a?(Hash)
                       config["collections"]
                     else
                       {}
                     end

      @collections = normalize_posts_meta(@collections)
      @collections.each_value do |meta|
        meta["categories"] = (meta["categories"] || []).to_set
      end

      @collections
    end


    def feed_template(collection, category, id)
      feed_source_path = File.expand_path "feed.xml", __dir__

      (config["templates"] || []).each do |entry|
        if (! entry.key? "collection" or collection == entry["collection"]) and
           (! entry.key? "category" or category == entry["category"]) and
           (! entry.key? "id" or id == entry["id"])

          feed_source_path = entry["path"]
          break
        end
      end

      @feed_templates.fetch(feed_source_path) {
        File.read(feed_source_path).gsub(MINIFY_REGEX, "")
      }
    end

    # Checks if a file already exists in the site source
    def file_exists?(file_path)
      File.exist? @site.in_source_dir(file_path)
    end

    # Generates contents for a file

    def make_page(file_path, collection, category: nil, id: nil)
      PageWithoutAFile.new(@site, __dir__, "", file_path).tap do |file|
        file.content = feed_template(collection, category, id)
        file.data.merge!(
          "layout"     => nil,
          "sitemap"    => false,
          "xsl"        => file_exists?("feed.xslt.xml"),
          "collection" => collection,
          "category"   => category
        )
        file.output
      end
    end

    # Special case the "posts" collection, which, for ease of use and backwards
    # compatability, can be configured via top-level keys or directly as a collection
    def normalize_posts_meta(hash)
      hash["posts"] ||= {}
      hash["posts"]["path"] ||= config["path"]
      hash["posts"]["categories"] ||= config["categories"]
      config["path"] ||= hash["posts"]["path"]
      hash
    end
  end
end
